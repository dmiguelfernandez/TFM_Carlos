"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractNotFoundError = exports.NoNetworkError = exports.NoBytecodeError = exports.ContractNotDeployedError = exports.UnlinkedContractError = exports.InvalidAddressError = exports.NoFunctionByThatNameError = exports.NoCompilationsForSpawnerError = exports.NoInternalInfoError = void 0;
/**
 * @category Exception
 * @protected
 */
class NoInternalInfoError extends Error {
    constructor() {
        super("No compilations provided, but userDefinedTypes or allocations is missing");
        this.name = "NoInternalInfoError";
    }
}
exports.NoInternalInfoError = NoInternalInfoError;
/**
 * @category Exception
 * @protected
 */
class NoCompilationsForSpawnerError extends Error {
    constructor() {
        super("Contract decoders cannot be spawned without compilations info");
        this.name = "NoCompilationsForSpawnerError";
    }
}
exports.NoCompilationsForSpawnerError = NoCompilationsForSpawnerError;
/**
 * @category Exception
 * @protected
 */
class NoFunctionByThatNameError extends Error {
    constructor(functionName, contractName) {
        const message = contractName
            ? `Contract ${contractName} has no function named ${functionName}`
            : `This contract has no function named ${functionName}`;
        super(message);
        this.functionName = functionName;
        this.contractName = contractName;
        this.name = "NoFunctionByThatNameError";
    }
}
exports.NoFunctionByThatNameError = NoFunctionByThatNameError;
//warning: copypasted from @truffle/decoder!
/**
 * This error indicates that an invalid address was passed to one of the
 * contract instance encoder spawners ([[forContractInstance]], etc).  Valid
 * addresses are those that Web3 accepts; i.e., either those with correct
 * checksums, or those that are all-lowercase or all-uppercase to deliberately
 * circumvent the checksum.
 * @category Exception
 */
class InvalidAddressError extends Error {
    constructor(address) {
        super(`Invalid address ${address}`);
        this.address = address;
        this.name = "InvalidAddressError";
    }
}
exports.InvalidAddressError = InvalidAddressError;
/**
 * This error indicates that you attempted to encode a contract creation
 * transaction for a contract that has not had all of its libraries linked.
 * @category Exception
 */
class UnlinkedContractError extends Error {
    constructor(contractName, bytecode) {
        const nameString = contractName !== undefined
            ? contractName + " "
            : "";
        super(`Contract ${nameString}has not had all its libraries linked`);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.name = "UnlinkedContractError";
    }
}
exports.UnlinkedContractError = UnlinkedContractError;
/**
 * This error indicates that you attempted to use address autodetection
 * for a contract that isn't deployed to the current network.
 * @category Exception
 */
class ContractNotDeployedError extends Error {
    constructor(contractName, networkId) {
        const nameString = contractName !== undefined
            ? contractName + " "
            : "";
        super(`Contract ${nameString}has not been deployed to network ${networkId} with deployer; address must be given explicitly`);
        this.contractName = contractName;
        this.name = "ContractNotDeployedError";
    }
}
exports.ContractNotDeployedError = ContractNotDeployedError;
/**
 * This error indicates that you attempted to encode a contract creation
 * transaction for a contract that lacks constructor bytecode.
 * @category Exception
 */
class NoBytecodeError extends Error {
    constructor(contractName) {
        const nameString = contractName !== undefined
            ? contractName + " "
            : "";
        super(`Contract ${nameString}has missing or empty constructor bytecode`);
        this.contractName = contractName;
        this.name = "NoBytecodeError";
    }
}
exports.NoBytecodeError = NoBytecodeError;
/**
 * This error indicates that the user attempted to do something that
 * requires a network ID (e.g.: autodetect an address for a deployed
 * contract) when no network ID or provider was set.
 * @category Exception
 */
class NoNetworkError extends Error {
    constructor() {
        super("This operation requires a provider or network ID.");
        this.name = "NoNetworkError";
    }
}
exports.NoNetworkError = NoNetworkError;
/**
 * This error indicates that the contract you are attempting to create an
 * encoder for does not appear in the project info.
 * @category Exception
 */
class ContractNotFoundError extends Error {
    constructor(contractName, bytecode, deployedBytecode, address) {
        let message;
        if (contractName) {
            message = `Contract ${contractName} could not be found in the project information`;
        }
        else if (address) {
            message = `Contract at ${address} could not be found in the project information`;
        }
        else {
            message = `Contract could not be found in the project information`;
        }
        super(message);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.deployedBytecode = deployedBytecode;
        this.name = "ContractNotFoundError";
    }
}
exports.ContractNotFoundError = ContractNotFoundError;
//# sourceMappingURL=errors.js.map