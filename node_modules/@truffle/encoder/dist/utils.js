"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.link = exports.isEthersBigNumber = exports.isBigNumber = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bignumber_1 = require("@ethersproject/bignumber");
const escapeRegExp_1 = __importDefault(require("lodash/escapeRegExp"));
// Unfortunately, both BigNumber and EthersBigNumber's isBigNumber methods
// **both return false positives on the other BigNumber class**.
// (This is because they both just check for the _isBigNumber flag.)
// As such, we've made our own method to recognize these, by
// A. using the appropriate method, but then also
// B. checking for the presence of a method that one class has but the other
// doesn't.
function isBigNumber(input) {
    return bignumber_js_1.default.isBigNumber(input) && Boolean(input.toFixed);
}
exports.isBigNumber = isBigNumber;
function isEthersBigNumber(input) {
    return bignumber_1.BigNumber.isBigNumber(input) && Boolean(input.toHexString);
}
exports.isEthersBigNumber = isEthersBigNumber;
//warning: copied (OK, adapted) from Truffle Contract!
function link(bytecode, links) {
    if (!bytecode) {
        return bytecode;
    }
    const names = Object.keys(links).sort((a, b) => b.length - a.length); //sort from longest to shortest
    //(this allows overlong names to be handled properly)
    for (const name of names) {
        const address = links[name];
        bytecode = bytecode.replace(
        //we have to escape as names may include '$'
        new RegExp(`__${escapeRegExp_1.default(name)}_*`, "g"), 
        //note: we don't have to worry about link references running into
        //one another, because each one is always preceded by a PUSH20 (0x73)
        address.slice(2) //cut off initial 0x
        );
    }
    return bytecode;
}
exports.link = link;
//# sourceMappingURL=utils.js.map