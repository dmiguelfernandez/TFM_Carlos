"use strict";
/**
 * # Truffle Encoder
 *
 * This module provides an interface for recognizing JavaScript user input of
 * Solidity values, encoding those values for use in a transaction, and performing
 * overload resolution based on those values to determine which Solidity method to
 * encode for.
 *
 * The interface is split into three classes: The project encoder, the contract
 * encoder, and the contract instance encoder.  The project encoder is associated
 * to the project as a whole; it can recognize user input, encode transactions,
 * and resolve overloads, although the interface for the latter two is somewhat
 * inconvenient.  The contract encoder is associated to a specific contract class.
 * It is similar to the project encoder, but presents an easier-to-use interface
 * for transaction encoding and overload resolution, so long as one is dealing
 * with methods of the specified class.  The contract instance encoder is
 * associated to a specific contract instance; it is like the contract encoder,
 * but is associated to a specific address, allowing the `to` option in
 * transactions to be populated automatically.
 *
 * ## Usage
 *
 * ### Initialization
 *
 * Create a encoder with one of the various constructor functions.
 *
 * For a project encoder, use the [[forProject|`forProject`]] function.
 *
 * For a contract encoder, use the [[forArtifact|`forArtifact`]] or
 * [[forContract|`forContract`]] function.
 *
 * For a contract instance encoder, use one of the following:
 * * [[forDeployedArtifact|`forDeployedArtifact`]]
 * * [[forDeployedContract|`forDeployedContract`]]
 * * [[forArtifactAt|`forArtifactAt`]]
 * * [[forContractAt|`forContractAt`]]
 * * [[forContractInstance|`forContractInstance`]]
 *
 * See the documentation of these functions for details, or below for usage
 * examples.
 *
 * All of these functions take a final argument in which information about the
 * project is specified; currently only a few methods for specifying project
 * information are allowed, but more are planned.
 *
 * One can also spawn encoders from other encoders by supplying additional
 * information.  See the documentation for the individual encoder classes for a
 * method listing.
 *
 * ### Encoder methods
 *
 * See the documentation for the individual encoder classes for a method listing.
 *
 * ### Wrapped format information
 *
 * When using the various "wrap" functions, values will be wrapped in
 * machine-readable [[Format.Values.Value]] objects containing individual wrapped
 * values.  (This is the same format that `@truffle/decoder` produces output in.)
 * See the [[Format|format documentation]] for an overview and complete module
 * listing.
 *
 * ### Use of project information and encoding of enums
 *
 * The encoder can do purely ABI-based encoding, like other encoders; however it
 * has the capability to use project information to do more.
 *
 * The most significant use of this is that if further project information is
 * present, this allows for enums to be entered as strings with the name of
 * the option, rather than having to be entered via the underlying number.
 * See the documentation of [[ProjectEncoder.wrap]] for more.
 *
 * Similarly, if project information is present, the encoder will also throw an
 * error if you attempt to put an out-of-range value into an enum type, and
 * refuse to consider overloads that would result in this during overload
 * resolution.  If project information is absent, the encoder will be unable to
 * recognize any error in these situations.
 *
 * ### ENS resolution
 *
 * The encoder supports ENS resolution for address and contract types if
 * initialized to support such.  See the documentation of the [[EncoderSettings]]
 * and [[EnsSettings]] types for more.
 *
 * ### Basic usage examples
 *
 * These usage examples are for a project with two contracts, `Contract1` and
 * `Contract2`.  Let's suppose these look like the following:
 *
 * ```solidity
 *pragma solidity ^0.8.0;
 *
 *contract Contract1 {
 *  function enumExample(Contract2.Ternary x) public payable {
 *  }
 *
 *  function overloaded(uint x) public payable {
 *  }
 *
 *  function overloaded(string x) public payable {
 *  }
 *}
 *
 *contract Contract2 {
 *  enum Ternary { No, Yes, Maybe }
 *}
 * ```
 *
 * #### Encoding a transaction
 *
 * ```typescript
 *import { forContract } from "@truffle/encoder";
 *const contract1 = artifacts.require("Contract1");
 *const contract2 = artifacts.require("Contract2");
 *const encoder = await Encoder.forContract(Contract1, [Contract1, Contract2]);
 *const abi = Contract1.abi.find(abiEntry => abiEntry.name === "enumExample");
 *const tx = await encoder.encodeTransaction(
 *  abi,
 *  ["Maybe", { value: 1 }],
 *  { allowOptions: true }
 *);
 * ```
 *
 * ### Performing overload resolution
 *
 * ```typescript
 *import { forContract } from "@truffle/encoder";
 *const contract1 = artifacts.require("Contract1");
 *const contract2 = artifacts.require("Contract2");
 *const encoder = await Encoder.forContract(Contract1, [Contract1, Contract2]);
 *const abis = Contract1.abi.filter(abiEntry => abiEntry.name === "overloaded");
 *const { tx, abi } = await encoder.encodeTransaction(
 *  abis,
 *  ["hello", { value: 1 }],
 *  { allowOptions: true }
 *);
 * ```
 *
 * @module @truffle/encoder
 * @packageDocumentation
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forContractInstance = exports.forContractAt = exports.forArtifactAt = exports.forDeployedContract = exports.forDeployedArtifact = exports.forContract = exports.forArtifact = exports.forProjectInternal = exports.forProject = exports.ProviderAdapter = exports.ContractNotDeployedError = exports.ContractNotFoundError = exports.UnlinkedContractError = exports.NoInternalInfoError = exports.InvalidAddressError = exports.ContractInstanceEncoder = exports.ContractEncoder = exports.ProjectEncoder = void 0;
const encoders_1 = require("./encoders");
Object.defineProperty(exports, "ProjectEncoder", { enumerable: true, get: function () { return encoders_1.ProjectEncoder; } });
Object.defineProperty(exports, "ContractEncoder", { enumerable: true, get: function () { return encoders_1.ContractEncoder; } });
Object.defineProperty(exports, "ContractInstanceEncoder", { enumerable: true, get: function () { return encoders_1.ContractInstanceEncoder; } });
var errors_1 = require("./errors");
Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function () { return errors_1.InvalidAddressError; } });
Object.defineProperty(exports, "NoInternalInfoError", { enumerable: true, get: function () { return errors_1.NoInternalInfoError; } });
Object.defineProperty(exports, "UnlinkedContractError", { enumerable: true, get: function () { return errors_1.UnlinkedContractError; } });
Object.defineProperty(exports, "ContractNotFoundError", { enumerable: true, get: function () { return errors_1.ContractNotFoundError; } });
Object.defineProperty(exports, "ContractNotDeployedError", { enumerable: true, get: function () { return errors_1.ContractNotDeployedError; } });
const adapter_1 = require("./adapter");
Object.defineProperty(exports, "ProviderAdapter", { enumerable: true, get: function () { return adapter_1.ProviderAdapter; } });
const codec_1 = require("@truffle/codec");
/**
 * **This function is asynchronous.**
 *
 * Constructs a project encoder for the project.
 * @category Constructors
 */
function forProject(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        const compilations = codec_1.Compilations.Utils.infoToCompilations(settings.projectInfo);
        const ens = ensSettingsForInfo(settings);
        const networkId = yield networkIdForInfo(settings);
        const encoder = new encoders_1.ProjectEncoder(Object.assign({ compilations, networkId }, ens));
        yield encoder.init();
        return encoder;
    });
}
exports.forProject = forProject;
/**
 * @protected
 * @category Constructors
 */
function forProjectInternal(info) {
    return __awaiter(this, void 0, void 0, function* () {
        const encoder = new encoders_1.ProjectEncoder(info);
        yield encoder.init();
        return encoder;
    });
}
exports.forProjectInternal = forProjectInternal;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract encoder for a given contract artifact.
 * @param artifact The artifact for the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[EncoderSettings]] to use;
 *   see the documentation for that type for more information.  If absent, the
 *   encoder will be based on just the single contract provided; it is
 *   recommended to pass more information to get the encoder's full power.
 *
 *   Note that if the artifact contains unlinked libraries, you will have to
 *   pass either the `provider` or `networkId` setting in order to encode
 *   contract creation transactions.
 * @category Constructors
 */
function forArtifact(artifact, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!settings.projectInfo) {
            settings = Object.assign(Object.assign({}, settings), { projectInfo: { artifacts: [artifact] } });
        }
        let projectEncoder = yield forProject(settings);
        return yield projectEncoder.forArtifact(artifact);
    });
}
exports.forArtifact = forArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract encoder for a given contract.
 * @param contract The contract the encoder is for.  It should have all of
 *   its libraries linked.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forArtifact(contract, Object.assign({ provider: contract.web3.currentProvider, networkId: parseInt(contract.network_id) || undefined }, settings));
    });
}
exports.forContract = forContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * You must pass in a provider or network ID to use this function.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[EncoderSettings]] to use, including the provider or
 *   network id; see the documentation for that type for more information.
 * @category Constructors
 */
function forDeployedArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractEncoder = yield forArtifact(artifact, settings);
        let instanceEncoder = yield contractEncoder.forInstance();
        return instanceEncoder;
    });
}
exports.forDeployedArtifact = forDeployedArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forDeployedContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractEncoder = yield forContract(contract, settings);
        return yield contractEncoder.forInstance();
    });
}
exports.forDeployedContract = forDeployedContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[EncoderSettings]] to use;
 *   see the documentation for that type for more information.  If absent, the
 *   encoder will be based on just the single contract provided; it is
 *   recommended to pass more information to get the encoder's full power.
 *
 *   Note that if the artifact contains unlinked libraries, you will have to
 *   pass either the `provider` or `networkId` setting in order to encode
 *   contract creation transactions.
 * @category Provider-based Constructor
 */
function forArtifactAt(artifact, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractEncoder = yield forArtifact(artifact, settings);
        let instanceEncoder = yield contractEncoder.forInstance(address);
        return instanceEncoder;
    });
}
exports.forArtifactAt = forArtifactAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a contract instance at a given address.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContractAt(contract, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractEncoder = yield forContract(contract, settings);
        return contractEncoder.forInstance(address);
    });
}
exports.forContractAt = forContractAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * @param contract The contract abstraction object corresponding to the contract instance.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContractInstance(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return forContractAt(contract.constructor, contract.address, settings);
    });
}
exports.forContractInstance = forContractInstance;
/**
 * @category Constructors
 */
function ensSettingsForInfo(settings) {
    if (settings.ens) {
        return settings.ens;
    }
    else {
        return {
            provider: settings.provider
        };
    }
}
/**
 * @category Constructors
 */
function networkIdForInfo(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (settings.networkId !== undefined) {
            return settings.networkId;
        }
        else if (settings.provider) {
            return yield new adapter_1.ProviderAdapter(settings.provider).getNetworkId();
        }
        else {
            return null;
        }
    });
}
//# sourceMappingURL=index.js.map