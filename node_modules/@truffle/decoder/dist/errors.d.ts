import type BN from "bn.js";
import { Format } from "@truffle/codec";
/**
 * This error indicates that the contract you are attempting to decode does not have AST
 * information associated with it, or that the decoder cannot find it.  This error will
 * be thrown if you attempt to use functions that require AST information with such a contract.
 * @category Exception
 */
export declare class ContractBeingDecodedHasNoNodeError extends Error {
    contractName: string;
    compilationId: string;
    constructor(contractName: string, compilationId: string);
}
/**
 * This error indicates that the contract you are attempting to decode could not be found in
 * the project info.  This error will be thrown if you attempt to spawn a contract decoder or
 * contract instance decoder for a contract not appearing in the project info.
 * @category Exception
 */
export declare class ContractNotFoundError extends Error {
    contractName: string;
    bytecode: string;
    deployedBytecode: string;
    address: string;
    constructor(contractName: string, bytecode: string, deployedBytecode: string, address: string);
}
/**
 * This error indicates that something went wrong while attempting to determine the location
 * of this contract's state variables.  This error will be thrown if you attempt to use
 * decoding functions after something went wrong during setup.  Unfortunately, we can't
 * always avoid this at the moment; we're hoping to make this more robust in the future
 * with Truffle DB.  In the meantime, it is at least worth noting that you should not encounter
 * this error if your entire project was written in Solidity and all compiled at once.  Sorry.
 * @category Exception
 */
export declare class ContractAllocationFailedError extends Error {
    id: number;
    contractName: string;
    compilationId: string;
    constructor(id: number, contractName: string, compilationId: string);
}
/**
 * This error indicates that an invalid address was passed to one of the
 * contract instance decoder spawners ([[forContractInstance]], etc).  Valid
 * addresses are those that Web3 accepts; i.e., either those with correct
 * checksums, or those that are all-lowercase or all-uppercase to deliberately
 * circumvent the checksum.
 * @category Exception
 */
export declare class InvalidAddressError extends Error {
    address: string;
    constructor(address: string);
}
/**
 * This error indicates that the user requested a variable that does not exist.
 * @category Exception
 */
export declare class VariableNotFoundError extends Error {
    nameOrId: string | number;
    constructor(nameOrId: string | number);
}
/**
 * This error indicates that the user requested a struct member that does not
 * exist.
 * @category Exception
 */
export declare class MemberNotFoundError extends Error {
    memberName: string;
    structType: Format.Types.StructType;
    variable: string | number;
    indices: any[];
    constructor(memberName: string, structType: Format.Types.StructType, variable: string | number, indices: any[]);
}
/**
 * This error indicates that the user requested an array index that is out
 * of bounds.  Note that currently this error is only thrown when an index
 * is requested that is outside *static* bounds; dynamic array bounds are
 * currently not checked.
 * @category Exception
 */
export declare class ArrayIndexOutOfBoundsError extends Error {
    index: BN;
    length: BN;
    variable: string | number;
    indices: any[];
    constructor(index: BN, length: BN, variable: string | number, indices: any[]);
}
/**
 * This error indicates that no provider was passed to the decoder.
 */
export declare class NoProviderError extends Error {
    constructor();
}
