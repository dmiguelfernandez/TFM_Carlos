import * as Abi from "@truffle/abi-utils";
import * as Codec from "@truffle/codec";
import { AbiData, Ast, Evm, Format, Contexts, Compilations, CalldataDecoding, LogDecoding, ReturndataDecoding, BlockSpecifier, RegularizedBlockSpecifier } from "@truffle/codec";
import { ProviderAdapter, Provider } from "@truffle/encoder";
import type * as DecoderTypes from "./types";
import type { ContractObject as Artifact } from "@truffle/contract-schema/spec";
/**
 * The ProjectDecoder class.  Decodes transactions and logs.  See below for a method listing.
 * @category Decoder
 */
export declare class ProjectDecoder {
    private providerAdapter;
    private compilations;
    private contexts;
    private deployedContexts;
    private contractsAndContexts;
    private referenceDeclarations;
    private userDefinedTypesByCompilation;
    private userDefinedTypes;
    private allocations;
    private codeCache;
    private ensSettings;
    /**
     * @protected
     */
    constructor(compilations: Compilations.Compilation[], provider: Provider, ensSettings?: DecoderTypes.EnsSettings);
    /**
     * @protected
     */
    getCode(address: string, block: RegularizedBlockSpecifier): Promise<Uint8Array>;
    /**
     * @protected
     */
    regularizeBlock(block: BlockSpecifier | null): Promise<RegularizedBlockSpecifier>;
    /**
     * **This method is asynchronous.**
     *
     * Takes a [[Transaction]] object and decodes it.  The result is a
     * [[CalldataDecoding]]; see the documentation on that interface for more.
     *
     * Note that decoding of transactions sent to libraries is presently not
     * supported and may have unreliable results.  Limited support for this is
     * planned for future versions.
     * @param transaction The transaction to be decoded.
     */
    decodeTransaction(transaction: DecoderTypes.Transaction): Promise<CalldataDecoding>;
    /**
     * @protected
     */
    decodeTransactionWithAdditionalContexts(transaction: DecoderTypes.Transaction, additionalContexts?: Contexts.Contexts, additionalAllocations?: {
        [selector: string]: AbiData.Allocate.FunctionCalldataAndReturndataAllocation;
    }): Promise<CalldataDecoding>;
    /**
     * **This method is asynchronous.**
     *
     * Takes a [[Log]] object and decodes it.  Logs can be ambiguous, so
     * this function returns an array of [[LogDecoding|LogDecodings]].
     *
     * Note that logs are decoded in strict mode, so (with one exception) none of the decodings should
     * contain errors; if a decoding would contain an error, instead it is simply excluded from the
     * list of possible decodings.  The one exception to this is that indexed parameters of reference
     * type cannot meaningfully be decoded, so those will decode to an error.
     *
     * If there are multiple possible decodings, they will always be listed in the following order:
     *
     * 1. Non-anonymous events coming from the contract itself (these will moreover be ordered
     *   from most derived to most base)
     * 2. Non-anonymous events coming from libraries
     * 3. Anonymous events coming from the contract itself (again, ordered from most derived
     *   to most base)
     * 4. Anonymous events coming from libraries
     *
     * You can check the kind and class.contractKind fields to distinguish between these.
     *
     * If no possible decodings are found, the returned array of decodings will be empty.
     *
     * Note that different decodings may use different decoding modes.
     *
     * Using `options.extras = "on"` or `options.extras = "necessary"` will change the
     * above behavior; see the documentation on [[ExtrasAllowed]] for more.
     *
     * If absolutely necessary, you can also set `options.disableChecks = true` to allow
     * looser decoding.  Only use this option if you know what you are doing.
     *
     * @param log The log to be decoded.
     * @param options Options for controlling decoding.
     */
    decodeLog(log: DecoderTypes.Log, options?: DecoderTypes.DecodeLogOptions): Promise<LogDecoding[]>;
    /**
     * @protected
     */
    decodeLogWithAdditionalOptions(log: DecoderTypes.Log, options?: DecoderTypes.EventOptions, additionalContexts?: Contexts.Contexts): Promise<LogDecoding[]>;
    /**
     * **This method is asynchronous.**
     *
     * Gets all events meeting certain conditions and decodes them.
     * This function is fairly rudimentary at the moment but more functionality
     * will be added in the future.
     * @param options Used to determine what events to fetch and how to decode
     *   them; see the documentation on the [[EventOptions]] type for more.
     * @return An array of [[DecodedLog|DecodedLogs]].
     *   These consist of a log together with its possible decodings; see that
     *   type for more info.  And see [[decodeLog]] for more info on how log
     *   decoding works in general.
     * @example `events({name: "TestEvent"})` -- get events named "TestEvent"
     *   from the most recent block
     */
    events(options?: DecoderTypes.EventOptions): Promise<DecoderTypes.DecodedLog[]>;
    /**
     * @protected
     */
    eventsWithAdditionalContexts(options?: DecoderTypes.EventOptions, additionalContexts?: Contexts.Contexts): Promise<DecoderTypes.DecodedLog[]>;
    /**
     * Takes a [[CalldataDecoding]], which may have been produced in full mode or ABI mode,
     * and converts it to its ABI mode equivalent.  See the README for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyCalldataDecoding(decoding: CalldataDecoding): CalldataDecoding;
    /**
     * Takes a [[LogDecoding]], which may have been produced in full mode or ABI mode,
     * and converts it to its ABI mode equivalent.  See the README for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyLogDecoding(decoding: LogDecoding): LogDecoding;
    /**
     * Takes a [[ReturndataDecoding]], which may have been produced in full mode
     * or ABI mode, and converts it to its ABI mode equivalent.  See the README
     * for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyReturndataDecoding(decoding: ReturndataDecoding): ReturndataDecoding;
    private getContextByAddress;
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract decoder for a given contract artifact.
     * @param artifact The artifact for the contract.
     *
     *   A contract constructor object may be substituted for the artifact, so if
     *   you're not sure which you're dealing with, it's OK.
     *
     *   Note: The artifact must be for a contract that the decoder knows about;
     *   otherwise you will have problems.
     */
    forArtifact(artifact: Artifact): Promise<ContractDecoder>;
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of a contract in this
     * project.
     * @param artifact The artifact for the contract.
     *
     *   A contract constructor object may be substituted for the artifact, so if
     *   you're not sure which you're dealing with, it's OK.
     *
     *   Note: The artifact must be for a contract that the decoder knows about;
     *   otherwise you will have problems.
     * @param address The address of the contract instance to decode.  If left out, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(artifact: Artifact, address?: string): Promise<ContractInstanceDecoder>;
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of a contract in this
     * project.  Unlike [[forInstance]], this method doesn't require an artifact; it
     * will automatically detect the class of the given contract.  If it's not in
     * the project, or the decoder can't identify it, you'll get an exception.
     * @param address The address of the contract instance to decode.
     *   If an invalid address is provided, this method will throw an exception.
     * @param block You can include this argument to specify that this should be
     *   based on the addresses content's at a specific block (if say the contract
     *   has since self-destructed).
     */
    forAddress(address: string, block?: BlockSpecifier): Promise<ContractInstanceDecoder>;
    /**
     * @protected
     */
    getReferenceDeclarations(): {
        [compilationId: string]: Ast.AstNodes;
    };
    /**
     * @protected
     */
    getUserDefinedTypes(): Format.Types.TypesById;
    /**
     * @protected
     */
    getAllocations(): Evm.AllocationInfo;
    /**
     * @protected
     */
    getProviderAdapter(): ProviderAdapter;
    /**
     * @protected
     */
    getEnsSettings(): DecoderTypes.EnsSettings;
    /**
     * @protected
     */
    getDeployedContexts(): Contexts.Contexts;
}
/**
 * The ContractDecoder class.  Decodes return values, and spawns the
 * [[ContractInstanceDecoder]] class.  Also, decodes transactions logs.  See
 * below for a method listing.
 * @category Decoder
 */
export declare class ContractDecoder {
    private providerAdapter;
    private contexts;
    private compilation;
    private contract;
    private artifact;
    private contractNode;
    private contractNetwork;
    private contextHash;
    private allocations;
    private noBytecodeAllocations;
    private userDefinedTypes;
    private stateVariableReferences;
    private projectDecoder;
    /**
     * @protected
     */
    constructor(contract: Compilations.Contract, compilation: Compilations.Compilation, projectDecoder: ProjectDecoder, artifact?: Artifact);
    /**
     * @protected
     */
    init(): Promise<void>;
    private get context();
    /**
     * **This method is asynchronous.**
     *
     * Decodes the return value of a call.  Return values can be ambiguous, so
     * this function returns an array of [[ReturndataDecoding|ReturndataDecodings]].
     *
     * Note that return values are decoded in strict mode, so none of the decodings should
     * contain errors; if a decoding would contain an error, instead it is simply excluded from the
     * list of possible decodings.
     *
     * If there are multiple possible decodings, they will always be listed in the following order:
     * 1. The decoded return value from a successful call.
     * 2. The decoded revert message from a call that reverted with a message.
     * 3. A decoding indicating that the call reverted with no message.
     * 4. A decoding indicating that the call self-destructed.
     *
     * You can check the kind and field to distinguish between these.
     *
     * If no possible decodings are found, the returned array of decodings will be empty.
     *
     * Note that different decodings may use different decoding modes.
     *
     * Decoding creation calls with this method is not supported.  If you simply
     * want to decode a revert message from an arbitrary call that you know
     * failed, you may also want to see the [[decodeRevert]] function in
     * `@truffle/codec`.
     *
     * @param abi The abi entry for the function call whose return value is being decoded.
     * @param data The data to be decoded, as a hex string (beginning with "0x").
     * @param options Additional options, such as the block the call occurred in.
     *   See [[ReturnOptions]] for more information.
     */
    decodeReturnValue(abi: Abi.FunctionEntry, data: string, options?: DecoderTypes.ReturnOptions): Promise<ReturndataDecoding[]>;
    /**
     * @protected
     */
    decodeReturnValueWithAdditionalContexts(abi: Abi.FunctionEntry, data: string, options?: DecoderTypes.ReturnOptions, additionalContexts?: Contexts.Contexts): Promise<ReturndataDecoding[]>;
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of this contract.
     * @param address The address of the contract instance decode.  If left out, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(address?: string): Promise<ContractInstanceDecoder>;
    private getCode;
    private regularizeBlock;
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeTransaction]].
     * @param transaction The transaction to be decoded.
     */
    decodeTransaction(transaction: DecoderTypes.Transaction): Promise<CalldataDecoding>;
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeLog]].
     * @param log The log to be decoded.
     */
    decodeLog(log: DecoderTypes.Log, options?: DecoderTypes.DecodeLogOptions): Promise<LogDecoding[]>;
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.events]].
     * @param options Used to determine what events to fetch and how to decode them;
     *   see the documentation on the EventOptions type for more.
     */
    events(options?: DecoderTypes.EventOptions): Promise<DecoderTypes.DecodedLog[]>;
    /**
     * See [[ProjectDecoder.abifyCalldataDecoding]].
     */
    abifyCalldataDecoding(decoding: CalldataDecoding): CalldataDecoding;
    /**
     * See [[ProjectDecoder.abifyLogDecoding]].
     */
    abifyLogDecoding(decoding: LogDecoding): LogDecoding;
    /**
     * See [[ProjectDecoder.abifyReturndataDecoding]].
     */
    abifyReturndataDecoding(decoding: ReturndataDecoding): ReturndataDecoding;
    /**
     * @protected
     */
    getAllocations(): Codec.Evm.AllocationInfo;
    /**
     * @protected
     */
    getStateVariableReferences(): Codec.Storage.Allocate.StateVariableAllocation[];
    /**
     * @protected
     */
    getProjectDecoder(): ProjectDecoder;
    /**
     * @protected
     */
    getNoBytecodeAllocations(): {
        [selector: string]: Codec.AbiData.Allocate.FunctionCalldataAndReturndataAllocation;
    };
    /**
     * @protected
     */
    getContractInfo(): DecoderTypes.ContractInfo;
}
/**
 * The ContractInstanceDecoder class.  Decodes storage for a specified
 * instance.  Also, decodes transactions, logs, and return values.  See below
 * for a method listing.
 *
 * Note that when using this class to decode transactions, logs, and return
 * values, it does have one advantage over using the ProjectDecoder or
 * ContractDecoder.  If the artifact for the class does not have a
 * deployedBytecode field, the ProjectDecoder (and therefore also the
 * ContractDecoder) will not be able to tell that this instance is of that
 * class, and so will fail to decode transactions sent to it or logs
 * originating from it, and will fall back to ABI mode when decoding return
 * values received from it.  However, the ContractInstanceDecoder has that
 * information and will make use of it, making it possible for it to decode
 * transactions sent to this instance, or logs originating from it, or decode
 * return values received from it in full mode, even if the deployedBytecode
 * field is missing.
 * @category Decoder
 */
export declare class ContractInstanceDecoder {
    private providerAdapter;
    private compilation;
    private contract;
    private contractNode;
    private contractNetwork;
    private contractAddress;
    private contractCode;
    private contextHash;
    private compiler;
    private contexts;
    private additionalContexts;
    private referenceDeclarations;
    private userDefinedTypes;
    private allocations;
    private stateVariableReferences;
    private internalFunctionsTable;
    private mappingKeys;
    private storageCache;
    private contractDecoder;
    private projectDecoder;
    private encoder;
    /**
     * @protected
     */
    constructor(contractDecoder: ContractDecoder, address?: string);
    /**
     * @protected
     */
    init(): Promise<void>;
    private get context();
    private checkAllocationSuccess;
    private decodeVariable;
    /**
     * **This method is asynchronous.**
     *
     * Returns information about the state of the contract, but does not include
     * information about the storage or decoded variables.  See the documentation
     * for the [[ContractState]] type for more.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     */
    state(block?: BlockSpecifier): Promise<DecoderTypes.ContractState>;
    /**
     * **This method is asynchronous.**
     *
     * Decodes the contract's variables; returns an array of these decoded variables.
     * See the documentation of the [[DecodedVariable]] type for more.
     *
     * Note that variable decoding can only operate in full mode; if the decoder wasn't able to
     * start up in full mode, this method will throw a [[ContractAllocationFailedError]].
     *
     * Note that decoding mappings requires first watching mapping keys in order to get any results;
     * see the documentation for [[watchMappingKey]].
     * Additional methods to make mapping decoding a less manual affair are planned for the future.
     *
     * Also, due to a technical limitation, it is not currently possible to
     * usefully decode internal function pointers.  See the
     * [[Format.Values.FunctionInternalValue|FunctionInternalValue]]
     * documentation and the README for more on how these are handled.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     */
    variables(block?: BlockSpecifier): Promise<DecoderTypes.StateVariable[]>;
    /**
     * **This method is asynchronous.**
     *
     * Decodes an individual contract variable; returns its value as a
     * [[Format.Values.Result|Result]].  See the documentation for
     * [[variables|variables()]] for various caveats that also apply here.
     *
     * If the variable can't be located, throws an exception.
     * @param nameOrId The name (or numeric ID, if you know that) of the
     *   variable.  Can be given as a qualified name, allowing one to get at
     *   shadowed variables from base contracts.  If given by ID, can be given as a
     *   number or numeric string.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     * @example Consider a contract `Derived` inheriting from a contract `Base`.
     *   Suppose `Derived` has a variable `x` and `Base` has variables `x` and
     *   `y`.  One can access `Derived.x` as `variable("x")` or
     *   `variable("Derived.x")`, can access `Base.x` as `variable("Base.x")`,
     *   and can access `Base.y` as `variable("y")` or `variable("Base.y")`.
     */
    variable(nameOrId: string | number, block?: BlockSpecifier): Promise<Format.Values.Result | undefined>;
    private findVariableByNameOrId;
    private getStorage;
    private getCode;
    private regularizeBlock;
    /**
     * **This method is asynchronous.**
     *
     * Watches a mapping key; adds it to the decoder's list of watched mapping
     * keys.  This affects the results of both [[variables|variables()]] and
     * [[variable|variable()]].  When a mapping is decoded, only the values at
     * its watched keys will be included in its value.
     *
     * Note that it is possible
     * to watch mappings that are inside structs, arrays, other mappings, etc;
     * see below for more on how to do this.
     *
     * Note that watching mapping keys is
     * only possible in full mode; if the decoder wasn't able to start up in full
     * mode, this method will throw an exception.
     *
     * (A bad variable name will cause an exception though; that input is checked.)
     * @param variable The variable that the mapping lives under; this works like
     *   the nameOrId argument to [[variable|variable()]].  If the mapping is a
     *   top-level state variable, put the mapping itself here.  Otherwise, put the
     *   top-level state variable it lives under.
     * @param indices Further arguments to watchMappingKey, if given, will be
     *   interpreted as indices into or members of the variable identified by the
     *   variable argument; see the example.  Array indices and mapping
     *   keys are specified by value; struct members are specified by name.
     *
     *   Values (for array indices and mapping keys) may be given in any format
     *   understood by Truffle Encoder; see the documentation for
     *   [[Encoder.ProjectEncoder.wrap|ProjectEncoder.wrap]] for details.
     *
     *   Note that if the path to a given mapping key
     *   includes mapping keys above it, any ancestors will also be watched
     *   automatically.
     * @example First, a simple example.  Say we have a mapping `m` of type
     *   `mapping(uint => uint)`.  You could call `watchMappingKey("m", 0)` to
     *   watch `m[0]`.
     * @example Now for a slightly more complicated example.  Say `m` is of type
     *   `mapping(uint => mapping(uint => uint))`, then to watch `m[3][5]`, you
     *   can call `watchMappingKey("m", 3, 5)`.  This will also automatically
     *   watch `m[3]`; otherwise, watching `m[3][5]` wouldn't do much of
     *   anything.
     * @example Now for a well more complicated example.  Say we have a struct
     *   type `MapStruct` with a member called `map` which is a `mapping(string => string)`,
     *   and say we have a variable `arr` of type `MapStruct[]`, then one could
     *   watch `arr[3].map["hello"]` by calling `watchMappingKey("arr", 3, "map", "hello")`.
     */
    watchMappingKey(variable: number | string, ...indices: unknown[]): Promise<void>;
    /**
     * **This method is asynchronous.**
     *
     * Opposite of [[watchMappingKey]]; unwatches the specified mapping key.  See
     * watchMappingKey for more on how watching mapping keys works, and on how
     * the parameters work.
     *
     * Note that unwatching a mapping key will also unwatch all its descendants.
     * E.g., if `m` is of type `mapping(uint => mapping(uint => uint))`, then
     * unwatching `m[0]` will also unwatch `m[0][0]`, `m[0][1]`, etc, if these
     * are currently watched.
     */
    unwatchMappingKey(variable: number | string, ...indices: unknown[]): Promise<void>;
    /**
     * **This method is asynchronous.**
     *
     * Behaves mostly as [[ProjectDecoder.decodeTransaction]].  However, it is
     * capable of more robustly decoding transactions that were sent to this
     * particular instance.
     */
    decodeTransaction(transaction: DecoderTypes.Transaction): Promise<CalldataDecoding>;
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeLog]].
     */
    decodeLog(log: DecoderTypes.Log, options?: DecoderTypes.DecodeLogOptions): Promise<LogDecoding[]>;
    /**
     * **This method is asynchronous.**
     *
     * See [[ContractDecoder.decodeReturnValue]].
     *
     * If the contract artifact is missing its bytecode, using this method,
     * rather than the one in [[ContractDecoder]], can sometimes provide
     * additional decoding information.
     */
    decodeReturnValue(abi: Abi.FunctionEntry, data: string, options?: DecoderTypes.ReturnOptions): Promise<ReturndataDecoding[]>;
    /**
     * See [[ProjectDecoder.abifyCalldataDecoding]].
     */
    abifyCalldataDecoding(decoding: CalldataDecoding): CalldataDecoding;
    /**
     * See [[ProjectDecoder.abifyLogDecoding]].
     */
    abifyLogDecoding(decoding: LogDecoding): LogDecoding;
    /**
     * See [[ProjectDecoder.abifyReturndataDecoding]].
     */
    abifyReturndataDecoding(decoding: ReturndataDecoding): ReturndataDecoding;
    /**
     * **This method is asynchronous.**
     *
     * This mostly behaves as [[ProjectDecoder.events]].
     * However, unlike other variants of this function, this one, by default, restricts to events originating from this instance's address.
     * If you don't want to restrict like that, you can explicitly use `address: undefined` in the options to disable this.
     * (You can also of course set a different address to restrict to that.)
     * @param options Used to determine what events to fetch; see the documentation on the [[EventOptions]] type for more.
     */
    events(options?: DecoderTypes.EventOptions): Promise<DecoderTypes.DecodedLog[]>;
    private constructSlot;
}
